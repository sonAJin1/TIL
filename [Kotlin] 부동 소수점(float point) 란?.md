
컴퓨터가 실수를 표현하는 방식
-
컴퓨터는 숫자를 표현 할 때 기본적으로 `2진수`를 사용합니다. 아래의 표를 참고해서 숫자를 나타내보면

![](https://steemitimages.com/640x0/https://steemitimages.com/DQmeKeVdmnTn5KAHD6aVk1x3ZkfWzM6XzW37efVd3rEtHxD/binary.png)

- 13 = 8+4+1 이므로 해당 자리 숫자를 1로 표현하고 나머지는 0으로 표현합니다. 그러면 1101 이 됩니다.
- 0.75 = 0.5+-0.25 이므로 0.11로 표현할 수 있습니다.

하지만, 이런 방법으로 표현하다보면 문제가 생기는 수들이 있습니다. 263.3 같은 실수를 2진수로 표현해보면 

-	263 => 100000111
-	0.3 => 0.01001100110011....의 무한 반복입니다.

이런 경우 컴퓨터에는 표현할 수 있는 가장 근사치의 값이 저장됩니다, 이 근사값을 저장하는 방법에는 두 가지가 있습니다.


고정 소수점
=
- 정수를 표현하는 비트 수와 소수를 표현하는 비트 수를 미리 정해 놓고 해당 비트 만큼만 사용해서 숫자를 표현하는 방식
예) 실수 표현에 4byte(32bit)를 사용하고 그 중 부호 1bit (아래에서 괄호로 표시), 정수 16bit, 소수 15bit를 사용하도록 약속해 놓은 시스템이 있다고 가정을 하고 여기서 263.3을 표현하면 (0)0000000100000111.010011001100110 이렇게 표현이 됩니다.
- 정수를 표현하는 bit를 늘리면 큰 숫자를 표현할 수 있지만 정밀한 숫자를 표현하긴 힘듭니다. 그래서 소수를 표현하는 bit를 늘릴 경우 정밀한 숫자를 표현할 수 있지만 큰 숫자를 표현하지 못합니다.
- 또한 
이러한 문제를 해결하기 위해서 **소수점을 고정하지 않는 부동 소수점(floating point)를 사용합니다.**


부동 소수점
=
부동 소수점은 **어디서부터 소수부인지의 정보 자체를 값에 포함시킵니다.** 일반적으로 IEEE에서 표준으로 제안한 방식을 사용합니다.

![IEEE 754](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/General_floating_point_ko.svg/500px-General_floating_point_ko.svg.png)

고정 소수점으로 나타낸 263.3을 2진수 부동 소수점 방식으로 변환해보겠습니다. 100000111.010011001100110... 으로 표현되던 것을 맨 앞에 있는 1 바로 뒤 소수점을 옮겨서 표현하도록 변환합니다. 그러면 1.00000111010011001100110... * 2^8(2의 8승) 으로 표현됩니다.

- 2^8의 8을 지수라고 하고 연두색 부분에 기록합니다. (IEEE 754 표현 방식에서는 127 + 지수를 기록합니다)
- 소수점 이후 숫자열 전체를 가수라고 하고 빨간색 부분에 기록합니다. 

이 방식에 따라서 263.3을 기록하면

- 부호 비트(1bit) : 0 (양수)
- 지수 비트(8bit) : 10000111 (127+8 = 135)
- 가수 비트(23bit) : 00000111010011001100110

하지만 여기서도 0.010011001100110은 정확히 0.3을 나타낼 수는 없습니다. 10진수로 나타내 보면 0.2998779296875을 나타냅니다. 


------
출처:
https://steemit.com/kr/@modolee/floating-point
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk2NDU5MzYwMiwtMTgxOTExMzUyM119
-->